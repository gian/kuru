(* Kuru grammar description file *)
(* Gian Perrone, 26 September 2010 *)

%name KuruParser
%start program

structure P = ParseTree

%nonterm sp of string
%nonterm _ of string
%nonterm digit of string
%nonterm num of string
%nonterm numdig of string
%nonterm int of P.pt
%nonterm real of P.pt
%nonterm negat of bool
%nonterm charconst of P.pt
%nonterm string of P.pt
%nonterm stringcont of string
%nonterm con of P.pt
%nonterm letter of string
%nonterm reserved of string
%nonterm nonid of string
%nonterm keyword of string
%nonterm id of P.pt
%nonterm idrest of string
%nonterm var of P.pt
%nonterm longid of P.pt
%nonterm exp of P.pt
%nonterm expel of P.pt
%nonterm explist of P.pt list
%nonterm expseq of P.pt list
%nonterm match of P.pt list
%nonterm pat of P.pt
%nonterm patel of P.pt
%nonterm patlist of P.pt list
%nonterm patapp of P.pt list
%nonterm typ of P.pt
%nonterm typel of P.pt
%nonterm tyannopt of P.pt option
%nonterm declist of P.pt list
%nonterm dec of P.pt
%nonterm valbind of P.pt list
%nonterm tyvarlist of P.pt list
%nonterm tyvars of P.pt list
%nonterm typebind of P.pt list
%nonterm funbind of P.pt list list
%nonterm funmatch of P.pt list
%nonterm databind of P.pt list
%nonterm conbind of P.pt list
%nonterm structdec of P.pt
%nonterm programel of P.pt
%nonterm program of P.pt list

val srcFileLineNum = ref 1

%%

sp             <- " " / "\n" -> ((srcFileLineNum := !srcFileLineNum + 1);"\n") / "\t".
_              <- sp _ / .

% Constants
digit          <- "0" / "1" / "2" / "3" / "4" / "5" / "6"
                      / "7" / "8" / "9".
num            <- d: numdig n: num -> ($d ^ $n) 
                / n: numdig -> ($n).
numdig         <- !sp d: digit -> ($d).

int            <- n: negat d: num -> (P.Int ($n,$d)).

real           <- n1: negat d1: num "." d2: num "e" n2: negat d3: num ->
                  (P.Real ($n1,$d1,$d2,SOME ($n2,$d3)))
                / n1: negat d1: num "." d2: num ->
                  (P.Real ($n1,$d1,$d2,NONE)).

negat          <- "~" -> (true)
                /     -> (false).

charconst      <- "#" "\"" c: char "\"" -> (P.Char ($c)).

string         <- "\"" s: stringcont "\"" _ -> (P.String ($s)).

stringcont     <- !"\\" !"\"" c: char s: stringcont -> ($c ^ $s)
                / b: "\\" c: char s: stringcont -> ($b ^ $c ^ $s)
                / -> ("").

con            <- real / int / charconst / string.

% Identifiers
letter         <- "a" / "b" / "c" / "d" / "e" / "f" / "g" / "h" / "i" /
                  "j" / "k" / "l" / "m" / "n" / "o" / "p" / "q" / "r" /
                  "s" / "t" / "u" / "v" / "w" / "x" / "y" / "z" /
                  "A" / "B" / "C" / "D" / "E" / "F" / "G" / "H" / "I" /
                  "J" / "K" / "L" / "M" / "N" / "O" / "P" / "Q" / "R" /
                  "S" / "T" / "U" / "V" / "W" / "X" / "Y" / "Z".

reserved       <- "!" / "%" / "&" / "$" / "+" / "-" /  "/" 
                / "<" / ">" / "?" / "@" / "\\" / "`" 
                / "^" / "*".

nonid          <- "(" / ")" / "[" / "]" / "." / ";" / "," / "|" /
                  "~" / "#" / ":" / "=>" / "=". 

keyword        <- "val" / "let" / "if" / "then" / "else" / "datatype"
                / "type" / "fn" / "fun" / "and" / "end" / "in" /
                  "structure" / "struct".

id             <-  r1: reserved r2: (reserved*) -> (P.Ident(String.concat($r1 :: $r2)))
                / k: keyword i1: idrest i2: (idrest*) -> 
                  (P.Ident($k ^ $i1 ^String.concat($i2)))
                / !keyword l: letter r: (idrest*) -> 
                  (P.Ident(String.concat ($l :: $r)))
                . 

idrest         <- !sp !nonid !reserved c: char -> ($c).

var            <- "'" i: id -> (P.Var ($i)).

longid         <- i: id "." l: longid -> (P.LongId ($i,$l))
                / i: id -> ($i).

% Expressions

exp            <- _ "raise" _ e: exp -> (P.Raise ($e))
                / _ e1: expel _ "andalso" _ e2: exp ->
                  (P.AndAlso($e1,$e2))
                / _ e1: expel _ "orelse" _ e2: exp ->
                  (P.OrElse($e1,$e2))
                / _ e: expel _ "handle" _ m: match ->
                  (P.HandleExp($e,$m))
                / _ e1: expel _ i: id _ e2: exp ->
                  (P.Infix($e1,$i,$e2))
                / _ e1: expel _ e2: exp -> 
                  (P.App($e1,$e2))
                / _ e: expel _ -> ($e).
                
expel          <- "op" _ l: longid -> (P.OpExp ($l))
                / "let"_ d: declist _"in"_ 
                     e1: exp _ ";"_ e2: expseq _ "end" ->
                        (P.LetExp($d,P.SeqExp($e1 :: $e2)))
                / "let"_ d: declist _"in"_ e: exp _ "end" ->
                        (P.LetExp($d,$e))
                / con
                / "(" _ e1: exp _ "," e2: explist _ ")" ->
                 (P.TupleExp ($e1 :: $e2))
                / "(" _ e1: exp _ ";" e2: expseq _ ")" ->
                  (P.SeqExp ($e1 :: $e2))
                / "(" _ e: exp _ ")" -> ($e)
                / "()" -> (P.UnitExp)
                / "[" _ e1: exp _ "," _ e2: explist _ "]" ->
                  (P.ListExp ($e1 :: $e2))
                / "[" _ e: exp _ "]" -> (P.ListExp [$e])
                / "if"_ e1: exp _"then"_ e2: exp _"else"_ e3: exp
                   -> (P.IfExp($e1,$e2,$e3))
                / "while"_ e1: exp _"do"_ e2: exp ->
                  (P.WhileExp($e1,$e2))
                / "case"_ e: exp _"of"_ m: match ->
                  (P.CaseExp($e,$m))
                / "fn"_ m: match -> (P.FnExp($m))
                / longid 
                .

explist        <- _ e1: exp _","_ e2: explist -> 
                  ($e1 :: $e2)
                / _ e: exp -> (([$e])).

expseq         <- _ e1: exp _";"_ e2: expseq -> 
                  ($e1 :: $e2)
                / _ e: exp -> (([$e])).

match          <- _ p: pat _"=>"_ e: exp _ "|"_ m: match ->
                  ((P.Match($p,$e)) :: $m)
                / _ p: pat _"=>"_ e: exp ->
                  ([P.Match($p,$e)]).

% Patterns

pat            <- _ p1: patel _"as"_ p2: pat -> (P.AsPat($p1,$p2))
                / _ p1: patel _ i: id _ p2: pat ->
                  (P.InfixPat($p1,$i,$p2))
                / _ patel.

patel          <- "_" -> (P.WildcardPat)
                / "(" _ p1: pat _ "," _ p2: patlist _ ")" ->
                  (P.TuplePat ($p1 :: $p2))
                / "(" _ p: pat _ ")" -> ($p)
                / "()" -> (P.UnitPat)
                / "[" _ p: patlist _ "]" -> (P.ListPat ($p))
                / c: con -> (P.ConPat ($c)) 
                / i: id -> (P.IdPat ($i))
                .

patlist        <- _ p1: pat _ "," _ p2: patlist -> ($p1 :: $p2)
                / _ p1: pat _ -> ([$p1]).

patapp         <- _ p1: pat _ p2: patlist -> ($p1 :: $p2)
                / _ p1: pat -> ([$p1]).

% Types

typ            <- _ t1: typel _ "->" _ t2: typ -> 
                  (P.TyArrow ($t1,$t2))
                / _ t1: typel _ "*" _ t2: typ ->
                  (P.TyPair ($t1,$t2))
                / _ t1: typel _ t2: typ ->
                  (P.TyCon ($t1,$t2))
                / _ t1: typel -> ($t1).

typel          <- v: var -> ($v)
                / "(" _ t: typ _ ")" -> ($t)
                / i: id -> (P.TyName ($i)).

tyannopt       <- _ ":" _ t: typ -> (SOME ($t))
                / -> (NONE).

% Declarations

declist        <- dec*.

dec            <- _ "val" _ v: valbind -> (P.ValDec($v))
                / _ "type" _ v: typebind -> (P.TypeDec($v))
                / _ "datatype" _ i: id _"="_ "datatype"_ l: longid
                  -> (P.DatatypeAssign ($i,$l))
                / _ "datatype" _ d: databind -> 
                     (P.DatatypeDec ($d))
                / _"fun" _ f: funbind -> (P.FunDec ($f))
                .

valbind        <- p: pat _"="_ e: exp _ "and" v: valbind ->
                  (P.ValBind ($p,$e) :: $v)
                / p: pat _"="_ e: exp ->
                  ([P.ValBind ($p,$e)]).

tyvarlist      <- _ v: var _ "," _ t: tyvarlist -> ($v :: $t)
                / _ v: var -> ([$v]).

tyvars         <- _"("_ l: tyvarlist _ ")" -> ($l)
                / _ v: var -> ([$v])
                / -> ([]).

typebind       <- _ tv: tyvars _ i: id _"="_ t: typ _ "and" 
                     l: typebind -> (P.TypeBind($tv,$i,$t) :: $l)
                / _ tv: tyvars _ i: id _"="_ t: typ ->
                     ([P.TypeBind($tv,$i,$t)]).

funbind        <- _ f: funmatch _ "and" _ l: funbind ->
                 ($f :: $l)
                / _ f: funmatch -> ([$f]).

funmatch       <- "op" _ i: id _ l: patapp _ t: tyannopt _"="_
                   e: exp _ "|"_ f: funmatch ->
                     (P.FunMatch (P.OpExp ($i),$l,$t,$e) :: $f)
                / "op" _ i: id _ l: patapp _ t: tyannopt _"="_
                   e: exp -> ([P.FunMatch(P.OpExp ($i),$l,$t,$e)])
                / i: id l: patapp t: tyannopt _"="_ e: exp _
                     "|"_ f: funmatch -> 
                     (P.FunMatch ($i,$l,$t,$e) :: $f)
                / i: id l: patapp t: tyannopt _"="_ e: exp ->
                     ([P.FunMatch ($i,$l,$t,$e)]).

databind       <- _ tv: tyvars _ i: id _ "=" _ c: conbind _ "and" d: databind
                  -> (P.DataBind($tv,$i,$c) :: $d)
                / _ tv: tyvars _ i: id _ "=" _ c: conbind
                  -> ([P.DataBind($tv,$i,$c)]).

conbind        <- _ i: id _ "of" _ t: typ _"|"_ c: conbind ->
                  (P.ConBind($i,SOME ($t)) :: $c)
                / _ i: id _ "of" _ t: typ ->
                  ([P.ConBind($i,SOME ($t))])
                / _ i: id _ "|" _ c: conbind ->
                  (P.ConBind($i,NONE) :: $c)
                / _ i: id ->
                  ([P.ConBind($i,NONE)]).

structdec      <- _ "structure" i: id _ "=" _ "struct"_ d: declist _ "end"
                  -> (P.Structure($i,NONE,$d)).

programel      <- _ dec
                / _ structdec.

program        <- p1: programel _ ";" _ p2: program -> ($p1 :: $p2)
                / p1: programel _ p2: program -> ($p1 :: $p2)
                / p: programel -> ([$p]).
