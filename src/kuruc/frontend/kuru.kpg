(*******************************************************************************
*  The Kuru Programming Language Compiler Toolset (http://www.kuru-lang.org)
*  Copyright (C) 2010  Gian Perrone
*
*  This program is free software: you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 3 of the License, or
*  (at your option) any later version.
*
*  This program is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*******************************************************************************
*  This file:
*    Primary Kuru PEG grammar. 
*
*  Partially derived from http://www.mpi-sws.org/~rossberg/sml.html
*  For a description of the grammar, see: 
*  http://www.kuru-lang.org/documentation/kuru-grammar
******************************************************************************)

%name KuruParser
%start program

structure P = ParseTree

%nonterm sp of string
%nonterm _ of string
%nonterm comment of string
%nonterm commentc of string
%nonterm num of string
%nonterm numdig of string
%nonterm int of P.pt
%nonterm real of P.pt
%nonterm negat of bool
%nonterm charconst of P.pt
%nonterm string of P.pt
%nonterm stringcont of string
%nonterm con of P.pt
%nonterm reserved of string
%nonterm nonid of string
%nonterm keyword of string
%nonterm id of P.pt
%nonterm idrest of string
%nonterm var of P.pt
%nonterm longid of P.pt
%nonterm exp of P.pt
%nonterm expel of P.pt
%nonterm expapp of P.pt list
%nonterm explist of P.pt list
%nonterm expseq of P.pt list
%nonterm match of P.pt list
%nonterm pat of P.pt
%nonterm patel of P.pt
%nonterm patlist of P.pt list
%nonterm patapp of P.pt list
%nonterm typ of P.pt
%nonterm typel of P.pt
%nonterm tyannopt of P.pt option
%nonterm typairlist of P.pt list
%nonterm typapp of P.pt list
%nonterm declist of P.pt list
%nonterm dec of P.pt
%nonterm valbind of P.pt list
%nonterm tyvarlist of P.pt list
%nonterm tyvars of P.pt list
%nonterm typebind of P.pt list
%nonterm funbind of P.pt list list
%nonterm funmatch of P.pt list
%nonterm databind of P.pt list
%nonterm conbind of P.pt list
%nonterm strbind of P.pt list
%nonterm str of P.pt
%nonterm sign of P.pt
%nonterm sdeclist of P.pt list
%nonterm sdec of P.pt
%nonterm sigasc_opt of P.ascription
%nonterm valdesc of P.pt list
%nonterm typedesc of P.pt list
%nonterm sigbind of P.pt list
%nonterm classbind of P.pt list
%nonterm strdesc of P.pt list
%nonterm programel of P.pt
%nonterm program of P.pt list

val srcFileLineNum = ref 1

val kuruFile = ref "__UNKNOWN__"

fun escape "n" = "\n"
  | escape "\\" = "\\"
  | escape "0" = String.str (Char.chr 0)
  | escape "t" = "\t"
  | escape "\"" = "\\\""
  | escape x = x

%%

sp             <- " " / "\n" -> ((srcFileLineNum := !srcFileLineNum + 1);"\n") / "\t".
_              <- sp _ / comment _ / .

comment        <- "(*" commentc "*)" -> ("").

commentc       <- !"*)" char commentc
                / .

% Constants
num            <- d: digit n: (digit*) -> (String.concat($d :: $n)). 

int            <- n: negat d: num -> (P.Int ($n,$d,(!pos,!kuruFile))).

real           <- n1: negat d1: num "." d2: num "e" n2: negat d3: num ->
                  (P.Real ($n1,$d1,$d2,SOME ($n2,$d3),(!pos,!kuruFile)))
                / n1: negat d1: num "." d2: num ->
                  (P.Real ($n1,$d1,$d2,NONE,(!pos,!kuruFile))).

negat          <- "~" -> (true)
                /     -> (false).

charconst      <- "#" "\"" c: stringcont "\"" -> (P.Char ($c,(!pos,!kuruFile))).

string         <- "\"" s: stringcont "\"" _ -> (P.String ($s,(!pos,!kuruFile))).

stringcont     <- !"\\" !"\"" c: char s: stringcont -> ($c ^ $s)
                / b: "\\" c: char s: stringcont -> ((escape ($c)) ^ $s)
                / -> ("").

con            <- real / int / charconst / string.

% Identifiers

reserved       <- "!" / "%" / "&" / "$" / "+" / "-" /  "/" 
                / "<=" / ">=" / ":=" / "::"
                / "<" / ">" / "?" / "@" / "\\" / "`" 
                / "^" / "*".

nonid          <- "(" / ")" / "[" / "]" / "." / ";" / "," / "|" /
                  "~" / "#" / ":" / "=>" / "=". 

keyword        <- "val" / "let" / "if" / "then" / "else" / "datatype"
                / "type" / "fn" / "fun" / "and" / "end" / "in" /
                  "structure" / "struct" / "of" / "case" /
                  "handle" / "raise" / "infixr" / "infix" /
                  "signature" / "sig" / "exception" / "open" / "local" /
                  "_import" / "as" / "class" / "implements"
                  .

id             <-  r1: reserved r2: (reserved*) -> 
                  (P.Ident(String.concat($r1 :: $r2),(!pos,!kuruFile)))
                / k: keyword i1: idrest i2: (idrest*) -> 
                  (P.Ident($k ^ $i1 ^String.concat($i2),(!pos,!kuruFile)))
                / !"_" !keyword !nonid l: alpha r: (idrest*) -> 
                  (P.Ident(String.concat ($l :: $r),(!pos,!kuruFile)))
                . 

idrest         <- !sp !nonid !reserved c: char -> ($c).

var            <- "''" i: id -> (P.Var ($i,(!pos,!kuruFile)))
                / "'" i: id -> (P.Var ($i,(!pos,!kuruFile))).

longid         <- i: id "." l: longid -> (P.LongId ($i,$l,(!pos,!kuruFile)))
                / i: id -> ($i).

% Expressions

exp            <- _ "raise" _ e: exp -> (P.Raise ($e,(!pos,!kuruFile)))
                / _ e1: expapp _ "andalso" _ e2: exp ->
                  (P.AndAlso(P.AppList($e1,(!pos,!kuruFile)),$e2,(!pos,!kuruFile)))
                / _ e1: expapp _ "orelse" _ e2: exp ->
                  (P.OrElse(P.AppList($e1,(!pos,!kuruFile)),$e2,(!pos,!kuruFile)))
                / _ e: expapp _ "handle" _ m: match ->
                  (P.HandleExp(P.AppList($e,(!pos,!kuruFile)),$m,(!pos,!kuruFile)))
                / _ e: expapp _ ":" _ t: typ ->
                  (P.TyAnn (P.AppList ($e,(!pos,!kuruFile)),$t,(!pos,!kuruFile)))
                / _ e1: expapp _"="_ e2: exp -> 
                  (P.Infix (P.AppList ($e1,(!pos,!kuruFile)),P.Ident ("=",(!pos,!kuruFile)),$e2,(!pos,!kuruFile)))
                / _ e1: expapp -> (P.AppList ($e1,(!pos,!kuruFile))).
                
expel          <- "op" _ l: longid -> (P.OpExp ($l,(!pos,!kuruFile)))
                / "let"_ d: declist _"in"_ 
                     e1: exp _ ";"_ e2: expseq _ "end" ->
                        (P.LetExp($d,P.SeqExp($e1 :: $e2,(!pos,!kuruFile)),(!pos,!kuruFile)))
                / "let"_ d: declist _"in"_ e: exp _ "end" ->
                        (P.LetExp($d,$e,(!pos,!kuruFile)))
                / con
                / "(" _ e1: exp _ "," e2: explist _ ")" ->
                 (P.TupleExp ($e1 :: $e2,(!pos,!kuruFile)))
                / "(" _ e1: exp _ ";" e2: expseq _ ")" ->
                  (P.SeqExp ($e1 :: $e2,(!pos,!kuruFile)))
                / "(" _ e: exp _ ")" -> ($e)
                / "()" -> (P.UnitExp ((!pos,!kuruFile)))
                / "[" _ e1: exp _ "," _ e2: explist _ "]" ->
                  (P.ListExp ($e1 :: $e2,(!pos,!kuruFile)))
                / "[" _ e: exp _ "]" -> (P.ListExp ([$e],(!pos,!kuruFile)))
                / "[" _ "]" -> (P.ListExp ([],(!pos,!kuruFile)))
                / "if"_ e1: exp _"then"_ e2: exp _"else"_ e3: exp
                   -> (P.IfExp($e1,$e2,$e3,(!pos,!kuruFile)))
                / "while"_ e1: exp _"do"_ e2: exp ->
                  (P.WhileExp($e1,$e2,(!pos,!kuruFile)))
                / "case"_ e: exp _"of"_ m: match ->
                  (P.CaseExp($e,$m,(!pos,!kuruFile)))
                / "fn"_ m: match -> (P.FnExp($m,(!pos,!kuruFile)))
                / longid 
                .

expapp         <- e1: expel _ e2: expapp -> ($e1 :: $e2)
                / e1: expel -> ([$e1]).

explist        <- _ e1: exp _","_ e2: explist -> 
                  ($e1 :: $e2)
                / _ e: exp -> (([$e])).

expseq         <- _ e1: exp _";"_ e2: expseq -> 
                  ($e1 :: $e2)
                / _ e: exp -> (([$e])).

match          <- _ p: pat _"=>"_ e: exp _ "|"_ m: match ->
                  ((P.Match($p,$e,(!pos,!kuruFile))) :: $m)
                / _ p: pat _"=>"_ e: exp ->
                  ([P.Match($p,$e,(!pos,!kuruFile))]).

% Patterns

pat            <- _ p1: patel _"as"_ p2: pat -> (P.AsPat($p1,$p2,(!pos,!kuruFile)))
                / _ p1: patel _ "::" _ p2: pat ->
                  (P.InfixPat($p1,P.Ident ("::",(!pos,!kuruFile)),$p2,(!pos,!kuruFile)))
                / _ p: patel _ ":"_ t: typ -> (P.TyAnnPat ($p,$t,(!pos,!kuruFile)))
                / _ i: longid _ p: patel -> (P.ConstrPat ($i,SOME ($p),(!pos,!kuruFile)))
                / _ patel.

patel          <- "_" -> (P.WildcardPat ((!pos,!kuruFile)))
                / i: longid -> (P.IdPat ($i,(!pos,!kuruFile)))
                / c: con -> (P.ConPat ($c,(!pos,!kuruFile)))
                / "(" _ p1: pat _ "," _ p2: patlist _ ")" ->
                  (P.TuplePat ($p1 :: $p2,(!pos,!kuruFile)))
                / "(" _ p: pat _ ")" -> ($p)
                / "()" -> (P.UnitPat ((!pos,!kuruFile)))
                / "[" _ p: patlist _ "]" -> (P.ListPat ($p,(!pos,!kuruFile)))
                / "[" _ "]" -> (P.ListPat ([],(!pos,!kuruFile)))
                .

patlist        <- _ p1: pat _ "," _ p2: patlist -> ($p1 :: $p2)
                / _ p1: pat _ -> ([$p1]).

patapp         <- _ p1: patel _ p2: patapp -> ($p1 :: $p2)
                / _ p1: patel -> ([$p1]).

% Types

typ            <- _ t1: typel _ "->" _ t2: typ ->
                     (P.TyArrow ($t1,$t2,(!pos,!kuruFile)))
                / _ t1: typapp ->
                     (P.TyPair ($t1,(!pos,!kuruFile)))
                / _ t1: typel _ t2: typ ->
                     (P.TyCon ($t1,$t2,(!pos,!kuruFile)))
                / _ t: typel -> ($t).

typel          <- v: var -> ($v)
                / i: longid _ t1: typel _ "=>" _ t2: typ ->
                  (P.TyClass ($i,$t1,$t2,(!pos,!kuruFile)))
                / !"*" i: longid -> (P.TyName ($i,(!pos,!kuruFile)))
                / "(" _ t: typ _ ")" -> ($t).

typapp			<- t1: typel _"*"_ t2: typapp ->
                  ($t1 :: $t2)
				    / t1: typel _"*"_ t2: typ ->
                  ([$t1,$t2]).

tyannopt       <- _ ":" _ t: typ -> (SOME ($t))
                / -> (NONE).

% Declarations

declist        <- dec*.

sdeclist        <- sdec*.

dec            <- _ "val" _ v: valbind -> (P.ValDec($v,(!pos,!kuruFile)))
                / _ "type" _ i1: typ _ "implements" _ i2: longid _"in"_
                     i3: longid ->
                        (P.ClassImpl($i1,$i2,$i3,(!pos,!kuruFile)))
                / _ "type" _ v: typebind -> (P.TypeDec($v,(!pos,!kuruFile)))
                / _ "datatype" _ i: id _"="_ "datatype"_ l: longid
                  -> (P.DatatypeAssign ($i,$l,(!pos,!kuruFile)))
                / _ "datatype" _ d: databind -> 
                     (P.DatatypeDec ($d,(!pos,!kuruFile)))
                / _"fun" _ f: funbind -> (P.FunDec ($f,(!pos,!kuruFile)))
                / _"structure" _ s: strbind -> (P.StructDec ($s,(!pos,!kuruFile)))
                / _"infixr" _ d: digit _ i: id -> (P.InfixrDec ($d,$i,(!pos,!kuruFile)))
                / _"infixr" _ i: id -> (P.InfixrDec ("",$i,(!pos,!kuruFile)))
                / _"infix" _ d: digit _ i: id -> (P.InfixDec ($d,$i,(!pos,!kuruFile)))
                / _"infix" _ i: id -> (P.InfixDec ("",$i,(!pos,!kuruFile)))
                / _"exception" _ i: id _ "of" _ t: typ -> 
                     (P.ExnDec ($i,SOME ($t),(!pos,!kuruFile)))
                / _"exception" _ i: id -> (P.ExnDec ($i,NONE,(!pos,!kuruFile)))
                / _"open" _ i: longid -> (P.OpenDec ($i,(!pos,!kuruFile)))
                / _"_import" _ i1: id _":"_ t: typ _"as"_ i2: id ->
                     (P.Import ($i1,$t,$i2,(!pos,!kuruFile)))
                .

sdec           <- _"val" _ v: valdesc -> (P.ValDesc($v,(!pos,!kuruFile)))
                / _ "type" _ v: typedesc -> (P.TypeDesc($v,(!pos,!kuruFile)))
                / _ "datatype" _ i: id _"="_ "datatype"_ l: longid
                  -> (P.DatatypeAssign ($i,$l,(!pos,!kuruFile)))
                / _ "datatype" _ d: databind -> 
                     (P.DatatypeDec ($d,(!pos,!kuruFile)))
                / _ "structure" _ s: strdesc -> (P.StructDesc($s,(!pos,!kuruFile)))
                .

valdesc        <- _ i: id _ ":" _ t: typ _ "and" _ v: valdesc ->
                     (P.ValDescBind (P.IdPat($i,(!pos,!kuruFile)),$t,(!pos,!kuruFile)) :: $v)
                / _ i: id _ ":" _ t: typ ->
                     ([P.ValDescBind (P.IdPat($i,(!pos,!kuruFile)),$t,(!pos,!kuruFile))]).

typedesc        <- _ t: tyvars _ i: id _ "and" _ v: typedesc ->
                     (P.TypeDescBind ($t,$i,(!pos,!kuruFile)) :: $v)
                 / _ t: tyvars _ i: id ->
                     ([P.TypeDescBind ($t,$i,(!pos,!kuruFile))]).

strdesc        <- _ i: id _ ":" _ s: sign _ "and" _ st: strdesc
                  -> (P.StructDescBind ($i,$s,(!pos,!kuruFile)) :: $st)
                / _ i: id _ ":" _ s: sign ->
                     ([P.StructDescBind ($i,$s,(!pos,!kuruFile))]).

valbind        <- "rec" _ v1: valbind ->
                  ([P.ValRec ($v1,(!pos,!kuruFile))])
                / "rec" _ v: valbind _ ->
                  ([P.ValRec ($v,(!pos,!kuruFile))])
                / p: patel _"="_ e: exp _ "and" v: valbind ->
                  (P.ValBind ($p,$e,(!pos,!kuruFile)) :: $v)
                / p: patel _"="_ e: exp ->
                  ([P.ValBind ($p,$e,(!pos,!kuruFile))]).

tyvarlist      <- _ v: var _ "," _ t: tyvarlist -> ($v :: $t)
                / _ v: var -> ([$v]).

tyvars         <- _"("_ l: tyvarlist _ ")" -> ($l)
                / _ v: var -> ([$v])
                / -> ([]).

typebind       <- _ tv: tyvars _ i: id _"="_ t: typ _ "and" 
                     l: typebind -> (P.TypeBind($tv,
                                     P.TyName ($i,(!pos,!kuruFile)),$t,(!pos,!kuruFile)) :: $l)
                / _ tv: tyvars _ i: id _"="_ t: typ ->
                     ([P.TypeBind($tv,P.TyName ($i,(!pos,!kuruFile)),$t,(!pos,!kuruFile))]).

funbind        <- _ f: funmatch _ "and" _ l: funbind ->
                 ($f :: $l)
                / _ f: funmatch -> ([$f]).

funmatch       <- "op" _ i: id _ l: patapp _ t: tyannopt _"="_
                   e: exp _ "|"_ f: funmatch ->
                     (P.FunMatch (P.OpExp ($i,(!pos,!kuruFile)),$l,$t,$e,(!pos,!kuruFile)) :: $f)
                / "op" _ i: id _ l: patapp _ t: tyannopt _"="_
                   e: exp -> ([P.FunMatch(P.OpExp ($i,(!pos,!kuruFile)),$l,$t,$e,(!pos,!kuruFile))])
                / i: id l: patapp t: tyannopt _"="_ e: exp _
                     "|"_ f: funmatch -> 
                     (P.FunMatch ($i,$l,$t,$e,(!pos,!kuruFile)) :: $f)
                / i: id l: patapp t: tyannopt _"="_ e: exp ->
                     ([P.FunMatch ($i,$l,$t,$e,(!pos,!kuruFile))]).

databind       <- _ tv: tyvars _ i: id _ "=" _ c: conbind _ "and" d: databind
                  -> (P.DataBind($tv,$i,$c,(!pos,!kuruFile)) :: $d)
                / _ tv: tyvars _ i: id _ "=" _ c: conbind
                  -> ([P.DataBind($tv,$i,$c,(!pos,!kuruFile))]).

conbind        <- _ i: id _ "of" _ t: typ _"|"_ c: conbind ->
                  (P.ConBind($i,SOME ($t),(!pos,!kuruFile)) :: $c)
                / _ i: id _ "of" _ t: typ ->
                  ([P.ConBind($i,SOME ($t),(!pos,!kuruFile))])
                / _ i: id _ "|" _ c: conbind ->
                  (P.ConBind($i,NONE,(!pos,!kuruFile)) :: $c)
                / _ i: id ->
                  ([P.ConBind($i,NONE,(!pos,!kuruFile))]).

strbind        <- _ i: id _ a: sigasc_opt _ "=" _ s: str _ "and" _ st: strbind ->
                  (P.StructBind($i,$a,$s,(!pos,!kuruFile)) :: $st)
                / _ i: id _ a: sigasc_opt _ "=" _ s: str ->
                  ([P.StructBind($i,$a,$s,(!pos,!kuruFile))]).

sigasc_opt     <- _":>"_ s: sign -> (P.AscribeOpaque ($s))
                / _":" _ s: sign -> (P.Ascribe ($s))
                / -> (P.Implicit).

sigbind        <- _ i: id _ "=" _ s: sign _ "and" _ st: sigbind ->
                  (P.SigBind($i,$s,(!pos,!kuruFile)) :: $st)
                / _ i: id _ "=" _ s: sign ->
                  ([P.SigBind($i,$s,(!pos,!kuruFile))]).

classbind      <- _ i: id _ "of" _ t:id _"=" _ s: sign _ "and" _ st: sigbind ->
                  (P.ClassBind($i,$t,$s,(!pos,!kuruFile)) :: $st)
                / _ i: id _ "of" _ t:id _"=" _ s: sign ->
                  ([P.ClassBind($i,$t,$s,(!pos,!kuruFile))]).

str            <- _ "struct" _ d: declist _ "end"
                  -> (P.Structure($d,(!pos,!kuruFile)))
                / longid.

sign           <- _ "sig" _ d: sdeclist _ "end"
                  -> (P.Signature($d,(!pos,!kuruFile)))
                / _ i: id -> ($i)
                .

programel      <- _ dec
                / _"signature" _ s: sigbind -> (P.SigDec ($s,(!pos,!kuruFile)))
                / _"class" _ s: classbind -> (P.ClassDec ($s,(!pos,!kuruFile))).

program        <- p1: programel _ ";" _ p2: program -> ($p1 :: $p2)
                / p1: programel _ p2: program -> ($p1 :: $p2)
                / p: programel -> ([$p]).
